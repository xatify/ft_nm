- there are three main types of object files
	* relocatable file: holds code and data suitable for linking with other object files
	* executable file: holds a program suitable for execution
	* shared object file

object files are binary representation of programs intended to execute durictly on a processor. ???!!!

object files participate in program linking (building a program) and program execution (running a program).

ELF header:
	- resides at the beginning and holds a "road map" describing the file's organization.
sections:
	- hold the bulk of object file information for the linking view:
		* instructions
		* data
		* symbol table
		* relocation information
		* ...
program header table: (optional)
	- tells the system how to create a process image.
	- reloactable files do not need one.

section header table:
	- informations describing the file's sections.
	- each section has an entry in the table; each entry gives information such as the
	section name, size, etc,

	- files used during linking must have a section header table.


!!!! only the ELF header has a fixed position in the file.

!!!! for portability reasons, ELF uses no bit-fields.

- the CPU in modern computer hardware performs reads and writes to memory most efficiently
when the data is naturally aligned.
- 


EI_CLASS e_ident [EI_CLASS], identifies the file's class, or capacity
    ELFCLASSNONE    0   Invalid class
    ELFCLASS32      1   32-bit objects
    ELFCLASS64      2   64-bit objects

EI_DATA e_ident[EI_DATA] specifies the data encoding of the processor-specific data
in the object file.
    ELFDATANONE     0   Invalid data encoding
    ELFDATA2LSB     1
    ELFDATA2MSB     2

    ELFDATA2MSB specifies 2's complement values, with the most significant 
    byte occupying the lowest address.



EI_PAD: this value marks the beginning of the unused bytes in e_ident.
these bytes are reserved and set to zero.

Sections:
An object file's section header table lets one locate all the file's sections.
the sections header table is an array of Elf32_Shdr structures
A section header table index is a subscript into this array.
e_shoff member gives the byte offset from the begining of the file to the
section header table.
e_shnum: tells how many entries the section header table contains.
e_shentsize: gives the size in bytes of each entry.

sections contain all information in an object file. except the ELF header.
the program header table, and section header table.


object file's sections satisfy several conditions:
    * Every section in an object file has exactly one section header describing it 
    * section headers may exist that do not have a section.
    * Each section occupies one contiguous (possibly empty) sequence of bytes
    within a file.
    * Sections in a file may not overlap
    * An object file may have inactive space. the various headers and sections
    might not "cover" every byte in an object file.


Section header
typedef struct {
    Elf32_Word  sh_name;
            - specifies the name of the section.
            - its value is an index into the section header string table section.
            - giving the location of a null terminated string.
    Elf32_Word  sh_type;
            - 
    Elf32_Word  sh_flags;
    Elf32_Addr  sh_addr;
            - if the section will appear in the memory image of a process.
            - this member gives the address at which the section's first byte
            - should reside. otherwise 0.
    Elf32_Off   sh_offset;
            - gives the offset from the beginning of the file to the first
            - byte in the section.
    Elf32_Word  sh_size;
            - gives the section's size in byte.
    Elf32_Word  sh_link;
            - section header table index link
    Elf32_Word  sh_info;
            - holds extra information
    Elf32_Word  sh_addralign;
            - 
    Elf32_Word  sh_entsize;
            - some sections hold a table of fixed-size entries, such as a symbol
            table.
            - for such a section, this member gives the size in bytes of each entry.
            - the member contains 0 if the section does not hold a table of
            - fixed-size entries.

}   Elf32_Shdr;


Static:
    - A set of object files, system libraries and library archives are
    statically bound, references are resolved, and an executable file is
    created that is completly self contained.
Dynamic:
    - A set of object files, libraries, system shared resources and other shared libraries
    are linked together to create the executable.
    - when this executable is loaded, other shared resources and dynamic libraries
    must be made available in the system for the program to run successfully.

-- there are also sections that support debugging: .debug .line
-- and program control, .bss .data .data1 .rodata .rodata1


.bss:
    this section holds uninitialized data that contribute to the to the
    program's memory image. By definition, the system initializes the data 
    with zeros.
    the section occupies no file space.

.data .data1:
    these sections hold initialized data contribute to the program's
    memory image.

.dynamic:
    holds dynamic linking information and has attributes such as 
    SHF_ALLOC and SHF_WRITE

.hash:
    holds a symblic hash table

.line:
    this section holds line number information for symblic debugging
    describes the correspondence between the source program and the machine
    code.

.rodata .rodata1:
    hold read-only data that typically contribute to a non-writable segment
    in the process image.

.shstrtab:
    holds section names

.strtab:
    holds strings, most commonly the strings that represent the names 
    associated with symbol table entries.

.symtab:
    hold a symbol table

.text:
    holds the "text", or executable instructions, of a program

Section names with a dot prefix are reserved for the system


- the object file format lets one define sections not in the list above.


----- String table ----------
string table sections hold null terminated character sequences, commonly called
strings.
the object file uses these strings to represent symbol and section names.

A section header's sh_name member holds an index into the section header string
table section.

------ Symbol Table ----------
an object file's symbol table holds information needed to locate and relocate 
a program's symbolic definitions and references.
A symbol table index is a subscript into this array.
index 0 both designates the first entry in the table and serves as the undefined
symbol index.

A symbol table entry has the following format.

typdef struct {
    Elf32_Word      st_name;
        - holds an index into the object file's symbol string table.
        - holds the character representations of the symbol names.
    Elf32_Addr      st_value;
        - gives the value of the associated symbol.
        - depending on the context this may be an absolute value
        - an address, ...
    Elf32_Word      st_size;
        - Many symbols have associated sizes, for example, a data object's size
        - is the number of bytes contained in the object.
        - this member holds 0 if the symbol has no size or an unknown size.

    unsigned char   st_info;
        - the symbol's type and binding attributes

        #define ELF32_ST_BIND(i) ((i)>>4)
        #define ELF32_ST_TYPE(i) ((i)&0xf)
        #define ELF32_ST_INFO(b,t) (((b)<<4) + ((t)&0xf))

    unsigned char  st_other;
        - holds 0 and has no defined meaning
    Elf32_Half      st_shndx;
        - Every symbol table entry is "defined" in relation to some section
        - this member holds the relevant section header table index.
} Elf32_Sym;


Symbol Binding, ELF32_ST_BIND
    - A symbol's binding determines the linkage visibility and behavior.

    STB_LOCAL       0
        - local symbols are not visible outside the object file containing 
        their definition.
        - local symbols of the same name may exist in multiple files without
        interfering with each other.
    STB_GLOBAL      1
        - Global symbols are visible to all object files being combined.
        - one file's definition of a global symbol will satisfy another file's
        - undefined reference to the same global symbol
    STB_WEAK        2
        - Weak symbols resemble global symbols, but their definitions have lower
        - precedence
    STB_LOPROC      13
    STB_HIPROC      15

    STB_LOPROC --> STB_HIPROC: value in this inclusive range are reserved for
    processor-specific semantics.

    in each symbol table, all symbols with STB_LOCAL binding precede the weak and
    global symbols


Symbol types, ELF32_ST_TYPE:
    STT_NOTYPE          0
        - the symbol's type is not specified
    STT_OBJECT          1
        - the symbol is associated with a data object, such as a variable, an
        array, and so on.
    STT_FUNC            2
        - associated with a function or other executable code.
    STT_SECTION         3
        - associated with a section, symbol table entries of this type
        exist primary for relocation and normally have STB_LOCAL binding.
    STT_FILE            4
        - 
    STT_LOPROC          13
    STT_HIPROC          15



the symbols in ELF object files convey specific information to the linker and
loader

Symbol values:
    symbol table entries for diffrent object file types have different interpretations
    for st_value member.
        - in relocatable files, st_value holds alignment constraints for a symbol
        whose section index is SHN_COMMON.
        - in relocatable files, st_value holds a section offset for a defined
        symbol. that is, st_value is an offset from the beginning of the section
        that st_shndx identifies.
        - in executable and shared object files, st_value holds a virtual address


--- Relocation ------
relocation is the process of connecting symbloc references with symblic definitions
for example, when a program calls a function, the associated call instruction must transfer
control to the proper destination address at execution.



!! should data order be supported
little endian / big endian 