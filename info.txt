- there are three main types of object files
	* relocatable file: holds code and data suitable for linking with other object files
	* executable file: holds a program suitable for execution
	* shared object file

object files are binary representation of programs intended to execute durictly on a processor. ???!!!

object files participate in program linking (building a program) and program execution (running a program).

ELF header:
	- resides at the beginning and holds a "road map" describing the file's organization.
sections:
	- hold the bulk of object file information for the linking view:
		* instructions
		* data
		* symbol table
		* relocation information
		* ...
program header table: (optional)
	- tells the system how to create a process image.
	- reloactable files do not need one.

section header table:
	- informations describing the file's sections.
	- each section has an entry in the table; each entry gives information such as the
	section name, size, etc,

	- files used during linking must have a section header table.


!!!! only the ELF header has a fixed position in the file.

!!!! for portability reasons, ELF uses no bit-fields.

- the CPU in modern computer hardware performs reads and writes to memory most efficiently
when the data is naturally aligned.
- 


EI_CLASS e_ident [EI_CLASS], identifies the file's class, or capacity
    ELFCLASSNONE    0   Invalid class
    ELFCLASS32      1   32-bit objects
    ELFCLASS64      2   64-bit objects

EI_DATA e_ident[EI_DATA] specifies the data encoding of the processor-specific data
in the object file.
    ELFDATANONE     0   Invalid data encoding
    ELFDATA2LSB     1
    ELFDATA2MSB     2

    ELFDATA2MSB specifies 2's complement values, with the most significant 
    byte occupying the lowest address.



EI_PAD: this value marks the beginning of the unused bytes in e_ident.
these bytes are reserved and set to zero.

Sections:
An object file's section header table lets one locate all the file's sections.
the sections header table is an array of Elf32_Shdr structures
A section header table index is a subscript into this array.
e_shoff member gives the byte offset from the begining of the file to the
section header table.
e_shnum: tells how many entries the section header table contains.
e_shentsize: gives the size in bytes of each entry.

sections contain all information in an object file. except the ELF header.
the program header table, and section header table.


object file's sections satisfy several conditions:
    * Every section in an object file has exactly one section header describing it 
    * section headers may exist that do not have a section.
    * Each section occupies one contiguous (possibly empty) sequence of bytes
    within a file.
    * Sections in a file may not overlap
    * An object file may have inactive space. the various headers and sections
    might not "cover" every byte in an object file.


Section header
typedef struct {
    Elf32_Word  sh_name;
            - specifies the name of the section.
            - its value is an index into the section header string table section.
            - giving the location of a null terminated string.
    Elf32_Word  sh_type;
            - 
    Elf32_Word  sh_flags;
    Elf32_Addr  sh_addr;
            - if the section will appear in the memory image of a process.
            - this member gives the address at which the section's first byte
            - should reside. otherwise 0.
    Elf32_Off   sh_offset;
            - gives the offset from the beginning of the file to the first
            - byte in the section.
    Elf32_Word  sh_size;
            - gives the section's size in byte.
    Elf32_Word  sh_link;
            - section header table index link
    Elf32_Word  sh_info;
            - holds extra information
    Elf32_Word  sh_addralign;
            - 
    Elf32_Word  sh_entsize;
            - some sections hold a table of fixed-size entries, such as a symbol
            table.
            - for such a section, this member gives the size in bytes of each entry.
            - the member contains 0 if the section does not hold a table of
            - fixed-size entries.

}   Elf32_Shdr;


Static:
    - A set of object files, system libraries and library archives are
    statically bound, references are resolved, and an executable file is
    created that is completly self contained.
Dynamic:
    - A set of object files, libraries, system shared resources and other shared libraries
    are linked together to create the executable.
    - when this executable is loaded, other shared resources and dynamic libraries
    must be made available in the system for the program to run successfully.

-- there are also sections that support debugging: .debug .line
-- and program control, .bss .data .data1 .rodata .rodata1


.bss:
    this section holds uninitialized data that contribute to the to the
    program's memory image. By definition, the system initializes the data 
    with zeros.
    the section occupies no file space.

.data .data1:
    these sections hold initialized data contribute to the program's
    memory image.

.dynamic:
    holds dynamic linking information and has attributes such as 
    SHF_ALLOC and SHF_WRITE

.hash:
    holds a symblic hash table

.line:
    this section holds line number information for symblic debugging
    describes the correspondence between the source program and the machine
    code.

.rodata .rodata1:
    hold read-only data that typically contribute to a non-writable segment
    in the process image.

.shstrtab:
    holds section names

.strtab:
    holds strings, most commonly the strings that represent the names 
    associated with symbol table entries.

.symtab:
    hold a symbol table

.text:
    holds the "text", or executable instructions, of a program

Section names with a dot prefix are reserved for the system


- the object file format lets one define sections not in the list above.


----- String table ----------
string table sections hold null terminated character sequences, commonly called
strings.
the object file uses these strings to represent symbol and section names.

A section header's sh_name member holds an index into the section header string
table section.

------ Symbol Table ----------
an object file's symbol table holds information needed to locate and relocate 
a program's symbolic definitions and references.
A symbol table index is a subscript into this array.
index 0 both designates the first entry in the table and serves as the undefined
symbol index.

A symbol table entry has the following format.

typdef struct {
    Elf32_Word      st_name;
        - holds an index into the object file's symbol string table.
        - holds the character representations of the symbol names.
    Elf32_Addr      st_value;
        - gives the value of the associated symbol.
        - depending on the context this may be an absolute value
        - an address, ...
    Elf32_Word      st_size;
        - Many symbols have associated sizes, for example, a data object's size
        - is the number of bytes contained in the object.
        - this member holds 0 if the symbol has no size or an unknown size.

    unsigned char   st_info;
        - the symbol's type and binding attributes

        #define ELF32_ST_BIND(i) ((i)>>4)
        #define ELF32_ST_TYPE(i) ((i)&0xf)
        #define ELF32_ST_INFO(b,t) (((b)<<4) + ((t)&0xf))

    unsigned char  st_other;
        - holds 0 and has no defined meaning
    Elf32_Half      st_shndx;
        - Every symbol table entry is "defined" in relation to some section
        - this member holds the relevant section header table index.
} Elf32_Sym;


Symbol Binding, ELF32_ST_BIND
    - A symbol's binding determines the linkage visibility and behavior.

    STB_LOCAL       0
        - local symbols are not visible outside the object file containing 
        their definition.
        - local symbols of the same name may exist in multiple files without
        interfering with each other.
    STB_GLOBAL      1
        - Global symbols are visible to all object files being combined.
        - one file's definition of a global symbol will satisfy another file's
        - undefined reference to the same global symbol
    STB_WEAK        2
        - Weak symbols resemble global symbols, but their definitions have lower
        - precedence
    STB_LOPROC      13
    STB_HIPROC      15

    STB_LOPROC --> STB_HIPROC: value in this inclusive range are reserved for
    processor-specific semantics.

    in each symbol table, all symbols with STB_LOCAL binding precede the weak and
    global symbols


Symbol types, ELF32_ST_TYPE:
    STT_NOTYPE          0
        - the symbol's type is not specified
    STT_OBJECT          1
        - the symbol is associated with a data object, such as a variable, an
        array, and so on.
    STT_FUNC            2
        - associated with a function or other executable code.
    STT_SECTION         3
        - associated with a section, symbol table entries of this type
        exist primary for relocation and normally have STB_LOCAL binding.
    STT_FILE            4
        - 
    STT_LOPROC          13
    STT_HIPROC          15



the symbols in ELF object files convey specific information to the linker and
loader

Symbol values:
    symbol table entries for diffrent object file types have different interpretations
    for st_value member.
        - in relocatable files, st_value holds alignment constraints for a symbol
        whose section index is SHN_COMMON.
        - in relocatable files, st_value holds a section offset for a defined
        symbol. that is, st_value is an offset from the beginning of the section
        that st_shndx identifies.
        - in executable and shared object files, st_value holds a virtual address


--- Relocation ------
relocation is the process of connecting symbloc references with symblic definitions
for example, when a program calls a function, the associated call instruction must transfer
control to the proper destination address at execution.



!! should data order be supported
little endian / big endian 



!! nm with no options sort the symbols


symbol type:
    - if lowercase: the symbol is usually local
    - if uppercase: the symbol is global (external)

    - there are however a few lowercase symbols that are shown 
        for special global symbols ("u", "v", "w")
    
    A
    the symbol's value is absolute, and will not be changed by further linking.
    
    B, b
    the symbol is in the BSS data section
    this section typically contains zero-initialized or uninitialized data.

    C, c
    the symbol is common
    common symbols are uninitialized data.

    D, d
    the symbol is in the initialized data section

    G, g
    the symbol is in an initialized data section for small objects.

    I
    the symbol is an indirect reference to another symbol

    N
    the symbol is a debugging symbol

    n
    the symbol is in the read-only section

    p
    the symbol is in a stack unwind section

    R, r 
    the symbol is in a read only section

    S, s
    The symbol is in an uninitialized or zero-initialized data section

    T, t
    the symbol is in the text section

    U
    the      is undefined

    u
    the symbol is a unique global symbol

    V, v
    the symbol is a weak object

    W, w
    the symbol is a weak symbol that has not been specifically tagged as a weak object
    symbol.

- nm chooses the character mostly based on the section in which the symbol 
appears.

the symbol binding (ELF32_ST_BIND(st_info)) determines whether the symbol is local
(lowercase), global (uppercase), or weak (v, w).

sh_shndx points to the section containing the symbol.


Symbol Table Entry

typdef struct {
    Elf32_Word      st_name;
    Elf32_Addr      st_value;
    Elf32_Word      st_size;
    unsigned char   st_info;
    unsigned char   st_other;
    Elf32_Half      st_shndx;
} Elf32_Sym;


st_name:
    - holds an index into the object file's symbol string table.
    
    !! external C symbols have the same names in C and object files's symbol tables

st_value:
    - the value of the associated symbol.
    - depending on the context, this may be an absolute value
    - an address

st_size:
    - symbols have associated sizes
    - a data object's size is the number of bytes contained in the object.
    - this member holds 0 if the symbol has no size or an unknown size

st_info:
    this member specifies the symbol's type and binding attributes
        A symbol's binding determines the linkage visibility and behavior.

            ELF32_ST_BIND
                STB_LOCAL       0
                STB_GLOBAL      1
                STB_WEAK        2
                STB_LOPROC      13
                STB_HIPROC      15

            STB_LOCAL:
                - local symbol are not visible outside the object file 
                containing their definition.
                - local symbols of the same name may exist in multiple files
                without interfering with each other.
            STB_GLOBAL:
                - Global symbols are visible to all files being combined.
                - one file's definition of a global symbol will satisfy another
                file's undefined reference to the same global symbol.
            
            STB_WEAK:
                - Weak symbols resemble global symbols, but their definitions
                have lower precedence.
            
            STB_LOPROC through STB_HIPROC:
                - values in this inclusive range are reserved for processor-
                specific semantics.
            
        
        in each symbol table, all symbols with STB_LOCAL binding precede the weak
        and global symbols.
    
    A symbol's type provides a general classification for the associated entity.
        
        ELF32_ST_TYPE
            STT_NOTYPE      0
            STT_OBJECT      1
            STT_FUNC        2
            STT_SECTION     3
            STT_FILE        4
            STT_LOPROC      13
            STT_HIPROC      15
        
        STT_NOTYPE:
            - the symbol type is not specific
        STT_OBJECT:
            - the symbol is associated with a data object
            - such as a variable or an array.
        STT_FUNC:
            - the symbol is associated with a function or
            - other executable code.
        STT_SECTION:
            - the symbol is associated with a section.
            - Symbol table entries of this type exist primarly
            - for relocation and normally have STB_LOCAL binding.
        STT_FILE:
            - the symbo's name gives the name of the source file associated with
            object file.
            - a file symbol has STB_LOCAL binding, it's section index is SHN_ABS
            - it precedes the other STB_LOCAL symbols for the file.
        STT_LOPROC -> STT_HIPROC:
            - values in this inclusive range are reserved for processor-
            specific semantics.
    
    if a symbol's value refers to a specific location within a section.
    it's section index member st_shndx holds an index into the section header
    table.

        as the section moves during the relocation, the symbol's value
        changes as well.

        some special section index values give other semantics.

        SHN_ABS:
            the symbol has an absolute value that will not change because
            of relocation.

        SHN_COMMON:
            the symbols labels a common block that has not yet been allocated.

        SHN_UNDEF:
            this section table index means the symbol is undefined. 
st_other:
    this member currently holds 0 and has no defined meaning.

st_shndx:
    every symbol table entry is "defined" in relation to some section
    this member holds the relevant section header table index.

Symbol Values:
    Symbol table entries for diffrent object file types have slightly different
    interpretations for the st_value:
        * in relocatable files: st_value holds alignment constraints for a symbol
        whose section index is SHN_COMMON.
        * in relocatable files, st_value holds a section offset for a defined 
        symbol. that is st_value is an offset from the begining of the section
        that st_shndx identifies.
        * in executable and shared object files
        st_value holds a virtual address 


A Weak symbol:
    denotes special a specially annotated symbol during linking of executable
    and linkable format.
    by default, without any annotation, a symbol in an object file is strong.

    During linking, a strong symbol can override w weak symbol of the same name.
    in the presence of two strong symbols by the same name the linker resolves
    the symbol in favor of the first one found.

    !! this behavior allows an executable to override standard library functions.




!! gcc-multilib is need to compile to x8086 32

